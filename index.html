<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://unpkg.com/echarts@5.4.3/dist/echarts.js"></script>
    <script src="https://unpkg.com/jquery@3.7.1/dist/jquery.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <style>
      .bottom-sheet {
        min-height: auto;
        max-height: 80vh;
        padding: 24px;
        overflow-y: auto;
        overflow: visible;
      }
    </style>
    </head>
  <body>
    <!-- Prepare a DOM with a defined width and height for ECharts -->
    <div id="main" style="width:90vw;height:100vh;"></div>

    <div id="bottom-sheet" class="modal bottom-sheet">
      <div class="modal-content">
        <h4>Settings</h4>
        <div class="row">
          <form class="col s12">
            <div class="row">
              <div class="input-field col s6">
                <select id="x-select" onchange="updateSelect(this.value, 'x')" class="material-select"></select>
                <label>X axis</label>
              </div>

              <div class="input-field col s6">
                <select id="y-select" onchange="updateSelect(this.value, 'y')" class="material-select"></select>
                <label>Y axis</label>
              </div>
            </div>
  
            <div class="row">
              <div class="input-field col s6">
                <select id="colour-select" onchange="updateSelect(this.value, 'colour')" class="material-select"></select>
                <label>Colour</label>
              </div>

              <div class="input-field col s6">
                <select id="multiple-select" onchange="updateSelect(this.value, 'multiple')" class="material-select"></select>
                <label>Small multiples</label>
              </div>
            </div>

            <div class="row">
              <div class="input-field col s6">
                <select id="palette-select" onchange="updateSelect(this.value, 'palette')" class="material-select"></select>
                <label>Palette</label>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>
  
    <script type="text/javascript">
      // Initialize the echarts instance based on the prepared dom
      var myChart = echarts.init(document.getElementById('main'));
      var store = null;
      var dimensions = null;
      var metbrewer = null;
      var datasetURL = null;
      var datasetTitle = null;
      // TODO: use a better data format (smaller sile, e.g. CSV)
      // TODO: new URL parameter to set/hide the title
      // TODO: new URL parameter to prevent setting the parameters
      // TODO: new URL parameter to choose the medatadata and stats JSON files
      // TODO: add field descriptions to metadata file and display
      var settings = {};
      var categories = [];
      var isSmallMultiple = false;
      var chartAxes = 0;
      var chartSeries = 0;
      var bottomSheet = document.querySelector('.bottom-sheet');
      var bottomSheetInstance = M.Modal.init(bottomSheet);
      const params = new URLSearchParams(location.search);
      if (params.get("metadataURL")) {
        settings.metadataURL = params.get("metadataURL");
      } else {
        settings.metadataURL = "sa-metadata.json";
      }

      // Create a promise for loading sa-dimensions.json
      var dimensionsPromise = $.get(settings.metadataURL).then(function(data) {
        dimensions = data.dimensions;
        datasetURL = data.dataset;
        datasetTitle = data.title;
        return data;
      });

      // Create a promise for loading metbrewer.json
      var metbrewerPromise = $.get('metbrewer.json').then(function(data) {
        metbrewer = data;
        return data;
      });

      // Use Promise.all to wait for both promises to resolve
      Promise.all([dimensionsPromise, metbrewerPromise]).then(function() {
        if (params.get("chartTitle")) {
          settings.chartTitle = params.get("chartTitle");
        } else {
          settings.chartTitle = "NI " + datasetTitle + " statistics explorer";
        }
        if (metbrewer.hasOwnProperty(params.get("palette"))) {
          settings.palette = params.get("palette");
        } else {
          settings.palette = "Signac";
        }
        if (dimensions.hasOwnProperty(params.get("x"))) {
          settings.x = params.get("x");
        } else {
          settings.x = Object.entries(dimensions).filter(a => a[1].type=='Metric')[0][0];
        }
        if (dimensions.hasOwnProperty(params.get("y"))) {
          settings.y = params.get("y");
        } else {
          settings.y = Object.entries(dimensions).filter(a => a[1].type=='Metric')[1][0];
        }
        if (dimensions.hasOwnProperty(params.get("colour"))) {
          settings.colour = params.get("colour");
        } else {
          settings.colour = Object.entries(dimensions).filter(a => a[1].type=='Category')[0][0];
        }
        if (dimensions.hasOwnProperty(params.get("smallMultiple"))) {
          settings.smallMultiple = params.get("smallMultiple");
        } else {
          settings.smallMultiple = 'None';
        }
        // Load sa-stats.json with the dynamically constructed URL
        $.get(datasetURL).done(function(data) {
          store = data.sort((a, b) => b.SA2011 - a.SA2011);
          Object.entries(dimensions).filter(v => v[1].bins).forEach((d, idx) => {
            const binSize = store.length / d[1].bins[0];
            const suffix = (d[1].bins[0]==10) ? ' decile' : (d[1].bins[0]==100) ? ' centile' : ' binned';
            // Calculate the binned variables
            store.map((a, idx) =>
            {
              return({
                index: idx,
                value: a[d[0]]
              });
            }).sort((a,b) => (a.value - b.value)).map((e, i) =>
            {
              const value = parseInt(i/binSize)+1;
              store[e.index][d[0] + suffix] = value;
            });
            dimensions[d[0] + suffix] = {
              type: 'Binned'
            };
            if (d[1].hasOwnProperty('extremes')) {
              dimensions[d[0] + suffix].extremes = d[1].extremes;
            }
            if (d[1].title) {
              dimensions[d[0] + suffix].title = d[1].title + suffix;
            }
          });
          updateChart();
          var elems = document.querySelectorAll('select');
          var instances = M.FormSelect.init(elems);

          // Fill out the options in the selectors based on the dimensions of the dataset
          // Hide x options when selected for y and vice versa
          var ogxm = createOptGroup('Metrics');
          var ogxb = createOptGroup('Binned metrics');
          var ogym = createOptGroup('Metrics');
          var ogmc = createOptGroup('Categories');
          var ogmb = createOptGroup('Binned metrics');
          var ogcc = createOptGroup('Categories');
          var ogcb = createOptGroup('Binned metrics');
          for (const [key, value] of Object.entries(dimensions)) {
            if (value.type == 'Metric') {
              ogxm.append(createOption(useTitleIfExists(key), key, (key == settings.x), (key == settings.y)));
              ogym.append(createOption(useTitleIfExists(key), key, (key == settings.y), (key == settings.x)));
            } else if (value.type == 'Category') {
              ogmc.append(createOption(useTitleIfExists(key), key, false, false));
              ogcc.append(createOption(useTitleIfExists(key), key, (key == settings.colour), false));
            } else if (value.type == 'Binned') {
              ogxb.append(createOption(useTitleIfExists(key), key, (key == settings.x), false));
              ogmb.append(createOption(useTitleIfExists(key), key, false, false));
              ogcb.append(createOption(useTitleIfExists(key), key, (key == settings.colour), false));
            }
          }
          ogym.append(createOption('Count of SAs', 'Count of SAs', false, true));
          document.getElementById("x-select").append(ogxm, ogxb);
          document.getElementById("y-select").append(ogym);
          ogmc.append(createOption('None', 'None', true, false));
          document.getElementById("multiple-select").append(ogmc, ogmb);
          document.getElementById("colour-select").append(ogcc, ogcb);

          for (const key of Object.keys(metbrewer)) {
            document.getElementById("palette-select").append(createOption(key, key, (key == settings.palette)));
          }
          hideSelected("y-select", settings.x, settings.y, (dimensions[settings.x].type == 'Binned'));
          hideSelected("x-select", settings.y, settings.x);
          $('#x-select').formSelect();
          $('#y-select').formSelect();
          $('#multiple-select').formSelect();
          $('#colour-select').formSelect();
          $('#palette-select').formSelect();
        });
      });

      function tooltipCallback(args) {
        return (
          ((args.data[3] != 'Count of SAs') ? (args.data[3] + '<br />') : '') +
          (dimensions[settings.x] ? useTitleIfExists(settings.x) : settings.x) + ': ' + args.data[0] + '<br />' +
          ((args.data[3] != 'Count of SAs') ? (useTitleIfExists(settings.y) + ': ') : ('Count of SAs: ')) + args.data[1] + '<br />' +
          args.marker + ' ' + useTitleIfExists(settings.colour) + ': ' + args.data[4]
        );
      }

      function createOptGroup(label) {
        var g = document.createElement("optgroup");
        g.label = label;
        return(g);
      }

      function createOption(text, value, selected, disabled) {
        var el = document.createElement("option");
        el.text = text;
        el.value = value;
        el.selected = selected;
        el.disabled = disabled;
        return(el);
      }

      function hideSelected(selectorId, hide, selected, showCountOfSAs = false) {
        var select = document.getElementById(selectorId);
        for (var i=0; i<select.length; i++) {
          if (select[i].value == 'Count of SAs') {
            select[i].disabled = !showCountOfSAs;
            select[i].selected = showCountOfSAs;
          } else {
            select[i].disabled = (select[i].value == hide) || (showCountOfSAs);
            select[i].selected = (select[i].value == selected) && (!showCountOfSAs);
          }
        }
      }

      function useTitleIfExists(column) {
        if (dimensions[column].hasOwnProperty('title')) {
          return(dimensions[column].title);
        } else {
          return(column);
        }
      }

      function labelExtremes(column, idx, maxIdx, value) {
        if ((dimensions[column].type == 'Binned') && (dimensions[column].hasOwnProperty('extremes'))) {
          if (idx == 0) {
            return (value + ' - ' + dimensions[column].extremes[0]);
          } else if (idx == maxIdx) {
            return (value + ' - ' + dimensions[column].extremes[1]);
          }
        }
        return (value);
      }

      function orderCategories(column) {
        var cats = [...new Set(store.map(a => a[column]))];
        if (dimensions[column].type == 'Binned') {
          cats.sort((a, b) => parseInt(a) - parseInt(b));
        } else if (dimensions[column].hasOwnProperty('order')) {
          cats.sort((a, b) => dimensions[column].order.indexOf(a) - dimensions[column].order.indexOf(b));
        } else {
          cats.sort();
        }
        return(cats);
      }

      $('.material-select').on('contentChanged', function() {
        $(this).formSelect();
      });

      // Specify the configuration items and data for the chart
      myChart.setOption({
        toolbox: {feature: {
          saveAsImage: {},
          myTool1: {
            show: true,
            title: 'Choose variables',
            icon: 'path://M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z',
            onclick: function (){
              bottomSheetInstance.open();
            }
          },
          myTool2: {
            show: true,
            title: 'Copy URL',
            icon: 'path://M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z',
            onclick: function (){
              const url = location.protocol + '//' + location.host + location.pathname + '?' + (new URLSearchParams(settings).toString());
              navigator.clipboard.writeText(url);
            }
          }
        }},
        tooltip: {trigger: "item", formatter: tooltipCallback},
      });

      function updateChart() {
        categories = orderCategories(settings.colour);
        isSmallMultiple = (settings.smallMultiple != 'None');
        var series = [];
        var yAxis = [];
        var xAxis = [];
        var grid = [];
        var titles = [];
        const xHasDataMin = dimensions[settings.x] ? (dimensions[settings.x].dataMin ? true : false) : false;
        const yHasDataMin = dimensions[settings.y] ? (dimensions[settings.y].dataMin ? true : false) : false;
        const yBinned = (dimensions[settings.y].type == 'Binned');
        const xBinned = (dimensions[settings.x].type == 'Binned');
        const colourBinned = (dimensions[settings.colour].type == 'Binned');
        const xCategories = xBinned ? [...new Set(store.map(a => a[settings.x]))] : [];
        if (isSmallMultiple) {
          var yCategories = orderCategories(settings.smallMultiple);
          const height = 100 / yCategories.length;
          const pixels = window.innerHeight;
          var multHeight = (pixels * height) / 100;
          if (multHeight < 200) {
            multHeight = 200;
            myChart.resize({height: ((multHeight+30)*yCategories.length)+50 + 'px'});
          } else {
            multHeight = multHeight - (pixels / 15);
            myChart.resize({height: ((multHeight+30)*yCategories.length)+50 + 'px'});
          }
          // Create the data object dependent on whether x is binned or not
          var data = {};
          yCategories.forEach(function(cat, idx) {
            if (dimensions[settings.x].type == 'Binned') {
              const subset = Object.entries(store.filter(d => d[settings.smallMultiple] == cat).reduce(
                function (acc, item) {
                  acc[item[settings.x]][item[settings.colour]]++;
                  return(acc);
                },
                Object.fromEntries([...new Set(store.map(a => a[settings.x]))].sort().map(a => [a, Object.fromEntries(categories.map(d => [d, 0]))])) // This is necessary for ordering of x axis
              )).sort(
                (a, b) => a[0] - b[0]
              ).map(
                e => Object.entries(e[1]).map(d => [e[0], d[1],  metbrewer[settings.palette].colours[categories.indexOf(colourBinned ? parseInt(d[0]) : d[0])], 'Count of SAs', colourBinned ? parseInt(d[0]) : d[0]])
              ).flat(1);
              data[cat] = subset;
            } else {
              data[cat] = store.filter(d => d[settings.smallMultiple] == cat).map(d => [d[settings.x], d[settings.y], metbrewer[settings.palette].colours[categories.indexOf(d[settings.colour])], d.SA2011, labelExtremes(settings.colour, categories.indexOf(d[settings.colour]), categories.length-1, d[settings.colour])]);
            }
          });
          // Get the y/x axis min/max after the data calculations
          const yMin = Object.values(data).flat().reduce((a,b) => (yBinned ? ((a < parseInt(b[1])) ? a : parseInt(b[1])) : ((a < b[1]) ? a : b[1])));
          var yMax = Object.values(data).flat().reduce((a,b) => (yBinned ? ((a > parseInt(b[1])) ? a : parseInt(b[1])) : ((a > b[1]) ? a : b[1])));
          const xMin = Object.values(data).flat().reduce((a,b) => (xBinned ? ((a < parseInt(b[0])) ? a : parseInt(b[0])) : ((a < b[0]) ? a : b[0])));
          const xMax = Object.values(data).flat().reduce((a,b) => (xBinned ? ((a > parseInt(b[0])) ? a : parseInt(b[0])) : ((a > b[0]) ? a : b[0])));
          if ((settings.smallMultiple!=settings.colour) && (xBinned)) {
            yCategories.forEach(function(cat, idx) {
              xCategories.forEach(function(col, cidx) {
                const subset = data[cat].filter(a => a[0]==col);
                const total = subset.reduce((a,b) => a+b[1], 0);
                yMax = (total > yMax) ? total : yMax;
              });
            });
          }
          // Set up the plots
          yCategories.forEach(function(cat, idx) {
            if ((settings.smallMultiple!=settings.colour) && (xBinned)) {
              categories.slice().reverse().forEach(function(col, cidx) {
                const subset = data[cat].filter(a => a[4]==col);
                series.push({
                  type: 'bar',
                  name: '',
                  id: (idx*categories.length)+cidx,
                  yAxisIndex: idx,
                  xAxisIndex: idx,
                  coordinateSystem: 'cartesian2d',
                  data : subset,
                  stack: cat,
                  itemStyle : {
                    color: function(data) {
                      return data.value[2];
                    }
                  }
                });
              });
            } else {
              series.push({
                type: xBinned ? 'bar' : 'scatter',
                name: ((settings.smallMultiple==settings.colour) ? labelExtremes(settings.smallMultiple, idx, yCategories.length-1, cat) : ''),
                id: idx,
                yAxisIndex: idx,
                xAxisIndex: idx,
                coordinateSystem: 'cartesian2d',
                data : data[cat],
                stack: xBinned ? cat : null,
                itemStyle : {
                  color: function(data) {
                    return data.value[2];
                  }
                }
              });
            }
            yAxis.push({
              id: idx,
              type: 'value',
              name: xBinned ? 'Count of SAs' : useTitleIfExists(settings.y),
              nameLocation: 'middle',
              nameGap: 40,
              gridIndex: idx,
              min: yHasDataMin ? yMin: null,
              max: yMax,
              axisLabel: {
                show: true,
                showMinLabel: yHasDataMin ? false : null,
                showMaxLabel: false
              },
              axisLine: {show: true},
              axisTick: {show: true}
            });
            xAxis.push({
              id: idx,
              type: xBinned ? 'category' : 'value',
              name: (idx == yCategories.length-1) ? useTitleIfExists(settings.x) : '',
              min: xHasDataMin ? xMin: null,
              max: xBinned ? xMax-1 : xMax,
              gridIndex: idx,
              axisLabel: {
                show: (idx == yCategories.length-1),
                showMinLabel: xHasDataMin ? false : null, 
                showMaxLabel: xHasDataMin ? false : null,
                formatter: function (value, idx) {
                  return (labelExtremes(settings.x, idx, xCategories.length-1, value));
                }
              },
              axisLine: {show: (idx == yCategories.length-1)},
              axisTick: {show: (idx == yCategories.length-1)}
            });
            grid.push({
              id: idx,
              left: '5%',
              right: '21%',
              top: ((multHeight+30)*idx)+50,
              height: multHeight,
            });
            titles.push({
              textAlign: 'right',
              text: labelExtremes(settings.smallMultiple, idx, yCategories.length-1, cat),
              left: '78%',
              top: ((multHeight+30)*idx)+30,
              textStyle: {
                fontSize: 14,
                fontWeight: 'normal'
              }
            });
          });
          if (settings.smallMultiple != settings.colour) {
            categories.forEach(function(cat, idx) {
              series.push(
                {
                  type: 'scatter',
                  name: labelExtremes(settings.colour, idx, categories.length-1, cat),
                  id: series.length,
                  data: null,
                  itemStyle : {
                    color: metbrewer[settings.palette].colours[idx]
                  }
                }
              );
            });
          }
        } else {
          myChart.resize({height: window.innerHeight});
          var data = {};
          categories.forEach(function(cat, idx) {
            if (xBinned) {
              data[idx] = Object.entries(store.filter(d => d[settings.colour] == cat).reduce(
                function (acc, item) {
                  acc[item[settings.x]]++;
                  return(acc)
                },
                Object.fromEntries([...new Set(store.map(a => a[settings.x]))].sort().map(a => [a, 0])) // This is necessary for ordering of x axis
              )).sort(
                (a, b) => a[0] - b[0]
              ).map(e => [e[0], e[1], cat, 'Count of SAs', cat]);
            } else {
              data[idx] = store.filter(d => d[settings.colour] == cat).map(d => [d[settings.x], d[settings.y], d[settings.colour], d.SA2011, d[settings.colour]]);
            }
          });
          categories.forEach(function(cat, idx) {
            const newidx = xBinned ? (categories.length-idx-1) : idx;
            series.push({
              type: xBinned ? 'bar': 'scatter',
              name: labelExtremes(settings.colour, newidx, categories.length-1, String(categories[newidx])),
              id: newidx,
              yAxisIndex: 0,
              xAxisIndex: 0,
              coordinateSystem: 'cartesian2d',
              data: data[newidx],
              stack: xBinned ? 'x': null,
              itemStyle : {
                color: metbrewer[settings.palette].colours[newidx]
              },
            });
          });
          yAxis.push({
            id: 0,
            type: isSmallMultiple ? 'category' : 'value',
            name: xBinned ? 'Count of SAs' : useTitleIfExists(settings.y),
            show: !isSmallMultiple,
            min: yHasDataMin ? 'dataMin': null,
            max: yHasDataMin ? 'dataMax': null,
            axisLabel: {
              showMinLabel: yHasDataMin ? false : null, 
              showMaxLabel: yHasDataMin ? false : null,
            },
          });
          xAxis.push({
            id: 0,
            type: xBinned ? 'category' : 'value',
            name: useTitleIfExists(settings.x),
            min: xHasDataMin ? 'dataMin': null,
            max: xHasDataMin ? 'dataMax': null,
            axisLabel: {
              showMinLabel: xHasDataMin ? false : null, 
              showMaxLabel: xHasDataMin ? false : null,
              formatter: function (value, idx) {
                return (labelExtremes(settings.x, idx, xCategories.length-1, value));
              }
            },
          });
          grid.push({
            id: 0,
            left: '5%',
            right: '21%',
            top: '50',
            height: '90%',
          });
          titles.push({
            text: ''
          });
        }
        if (series.length < chartSeries) {
          for (var idx = series.length; idx < chartSeries; idx++)
          {
            series.push(
              {
                type: 'scatter',
                id: idx,
                showSymbol: false,
                data: [],
                name: ''
              }
            );
          }
        }
        if (yAxis.length < chartAxes) {
          for (var idx = yAxis.length; idx < chartAxes; idx++)
          {
            yAxis.push({
              name: '',
              id: idx,
              axisLabel: {show: false},
              axisLine: {show: false},
              axisTick: {show: false}
            });
            xAxis.push({
              name: '',
              id: idx,
              axisLabel: {show: false},
              axisLine: {show: false},
              axisTick: {show: false}
            });
            grid.push({
              id: idx,
              left: '5%',
              right: '21%',
              top: '50',
              height: '0%',
              show: false
            });
            titles.push({
              text: ''
            });
          }
        }
        titles.push({text: settings.chartTitle});
        chartSeries = series.length;
        chartAxes = yAxis.length;
        var legendData = [];
        categories.forEach(function(cat, idx) {
          const name = labelExtremes(settings.colour, idx, categories.length-1, String(cat));
          if ((settings.smallMultiple == settings.colour) || (!isSmallMultiple & xBinned)) {
            legendData.push({
              name: name,
              itemStyle: {color: metbrewer[settings.palette].colours[idx]},
            });
          } else {
            legendData.push(name);
          }
        });
        myChart.setOption({
          title: titles,
          grid: grid,
          xAxis: xAxis,
          yAxis: yAxis,
          series: series,
          legend : {
            top: 'middle',
            right: 0,
            orient: 'vertical',
            align: 'right',
            icon: 'roundRect',
            data: legendData,
          },
        });
      }

      // When the selectors change, update the chart options
      function updateSelect(name, target) {
        if (target == 'x') {
          settings.x = name;
          updateChart();
          // Hide relevant y options
          hideSelected("y-select", settings.x, settings.y, (dimensions[settings.x].type == 'Binned'));
          $('#y-select').formSelect();
        } else if (target == 'y') {
          settings.y = name;
          updateChart();
          // Hide relevant x options
          hideSelected("x-select", settings.y, settings.x);
          $('#x-select').formSelect();
        } else if (target == 'multiple') {
          settings.smallMultiple = name;
          updateChart();
        } else if (target == 'colour') {
          settings.colour = name;
          updateChart();
          // Handle the case where the palette doesn't hold enough colours by hiding options and selecting an alternative
          var change = false;
          if (categories.length > metbrewer[settings.palette].colours.length) {
            change = true;
          }
          var pselect = document.getElementById("palette-select");
          for (var i=0; i<pselect.length; i++) {
            if (categories.length > metbrewer[pselect[i].value].colours.length) {
              pselect[i].disabled = true;
              pselect[i].selected = false;
            } else {
              pselect[i].disabled = false;
              if (change) {
                settings.palette = pselect[i].value;
                pselect[i].selected = true;
                change = false;
                updateChart();
              }
            }
          }
          $('#palette-select').formSelect();
        } else if (target == 'palette') {
          settings.palette = name;
          updateChart();
        }
      }

    </script>
  </body>
</html>
